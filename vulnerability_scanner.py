"""
Advanced Vulnerability Scanner for Telegram Bot
Scans for known vulnerabilities, CVEs, and security issues
"""

import socket
import ssl
import requests
import asyncio
import aiohttp
import subprocess
import re
from datetime import datetime
from typing import Dict, List, Any, Optional
import json

class VulnerabilityScanner:
    def __init__(self):
        self.session = None
        self.common_ports = {
            21: 'FTP',
            22: 'SSH', 
            23: 'Telnet',
            25: 'SMTP',
            53: 'DNS',
            80: 'HTTP',
            110: 'POP3',
            143: 'IMAP',
            443: 'HTTPS',
            993: 'IMAPS',
            995: 'POP3S'
        }
        
        # Common vulnerabilities to check
        self.vuln_checks = [
            'ssl_vulnerabilities',
            'http_headers_security', 
            'open_ports_analysis',
            'service_version_check',
            'weak_ciphers',
            'certificate_validation'
        ]
    
    async def scan_vulnerabilities(self, target: str) -> Dict[str, Any]:
        """Main vulnerability scanning function"""
        results = {
            'target': target,
            'scan_time': datetime.now().isoformat(),
            'vulnerabilities': [],
            'security_score': 0,
            'recommendations': [],
            'details': {}
        }
        
        try:
            # Resolve target to IP
            target_ip = await self._resolve_target(target)
            results['target_ip'] = target_ip
            
            # Run vulnerability checks
            ssl_results = await self._check_ssl_vulnerabilities(target)
            headers_results = await self._check_http_headers(target)
            ports_results = await self._analyze_open_ports(target_ip)
            service_results = await self._check_service_versions(target_ip)
            
            # Compile results
            all_results = [ssl_results, headers_results, ports_results, service_results]
            
            for check_result in all_results:
                if check_result and 'vulnerabilities' in check_result:
                    results['vulnerabilities'].extend(check_result['vulnerabilities'])
                if check_result and 'details' in check_result:
                    results['details'].update(check_result['details'])
            
            # Calculate security score
            results['security_score'] = self._calculate_security_score(results)
            
            # Generate recommendations
            results['recommendations'] = self._generate_recommendations(results)
            
        except Exception as e:
            results['error'] = f"Scan failed: {str(e)}"
            
        return results
    
    async def _resolve_target(self, target: str) -> str:
        """Resolve domain to IP address"""
        try:
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(None, socket.gethostbyname, target)
            return result
        except:
            # If it's already an IP, return as-is
            return target
    
    async def _check_ssl_vulnerabilities(self, target: str) -> Dict[str, Any]:
        """Check SSL/TLS vulnerabilities"""
        results = {
            'vulnerabilities': [],
            'details': {'ssl_info': {}}
        }
        
        try:
            # Check if HTTPS is available
            async with aiohttp.ClientSession() as session:
                try:
                    async with session.get(f'https://{target}', timeout=10) as response:
                        # SSL is available, check for vulnerabilities
                        ssl_info = await self._get_ssl_info(target)
                        results['details']['ssl_info'] = ssl_info
                        
                        # Check for weak SSL versions
                        if ssl_info.get('protocol_version', '').startswith('TLS'):
                            version = ssl_info.get('protocol_version', '')
                            if 'TLSv1.0' in version or 'TLSv1.1' in version:
                                results['vulnerabilities'].append({
                                    'type': 'Weak TLS Version',
                                    'severity': 'Medium',
                                    'description': f'Using outdated TLS version: {version}',
                                    'recommendation': 'Upgrade to TLS 1.2 or higher'
                                })
                        
                        # Check certificate expiry
                        if ssl_info.get('expires_in_days', 365) < 30:
                            results['vulnerabilities'].append({
                                'type': 'Certificate Expiry',
                                'severity': 'High',
                                'description': f'SSL certificate expires in {ssl_info.get("expires_in_days")} days',
                                'recommendation': 'Renew SSL certificate immediately'
                            })
                            
                except:
                    # HTTPS not available
                    results['vulnerabilities'].append({
                        'type': 'No HTTPS',
                        'severity': 'Medium', 
                        'description': 'No HTTPS encryption available',
                        'recommendation': 'Implement HTTPS with valid SSL certificate'
                    })
                    
        except Exception as e:
            results['details']['ssl_error'] = str(e)
            
        return results
    
    async def _get_ssl_info(self, target: str) -> Dict[str, Any]:
        """Get detailed SSL certificate information"""
        ssl_info = {}
        try:
            context = ssl.create_default_context()
            with socket.create_connection((target, 443), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=target) as ssock:
                    cert = ssock.getpeercert()
                    ssl_info['subject'] = dict(x[0] for x in cert['subject'])
                    ssl_info['issuer'] = dict(x[0] for x in cert['issuer'])
                    ssl_info['version'] = cert['version']
                    ssl_info['serial_number'] = cert['serialNumber']
                    ssl_info['not_before'] = cert['notBefore']
                    ssl_info['not_after'] = cert['notAfter']
                    ssl_info['protocol_version'] = ssock.version()
                    
                    # Calculate days until expiry
                    from datetime import datetime
                    expiry_date = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                    days_left = (expiry_date - datetime.now()).days
                    ssl_info['expires_in_days'] = days_left
                    
        except Exception as e:
            ssl_info['error'] = str(e)
            
        return ssl_info
    
    async def _check_http_headers(self, target: str) -> Dict[str, Any]:
        """Check HTTP security headers"""
        results = {
            'vulnerabilities': [],
            'details': {'headers': {}}
        }
        
        try:
            async with aiohttp.ClientSession() as session:
                for protocol in ['https', 'http']:
                    try:
                        async with session.get(f'{protocol}://{target}', timeout=10) as response:
                            headers = dict(response.headers)
                            results['details']['headers'][protocol] = headers
                            
                            # Check for missing security headers
                            security_headers = {
                                'X-Frame-Options': 'Clickjacking protection missing',
                                'X-Content-Type-Options': 'MIME type sniffing protection missing',
                                'X-XSS-Protection': 'XSS protection header missing',
                                'Strict-Transport-Security': 'HSTS header missing (HTTPS only)',
                                'Content-Security-Policy': 'CSP header missing'
                            }
                            
                            for header, description in security_headers.items():
                                if header not in headers:
                                    if header == 'Strict-Transport-Security' and protocol == 'http':
                                        continue  # HSTS only applies to HTTPS
                                    results['vulnerabilities'].append({
                                        'type': 'Missing Security Header',
                                        'severity': 'Medium',
                                        'description': description,
                                        'recommendation': f'Add {header} header'
                                    })
                            
                            # Check Server header disclosure
                            if 'Server' in headers:
                                results['vulnerabilities'].append({
                                    'type': 'Information Disclosure',
                                    'severity': 'Low',
                                    'description': f'Server header reveals: {headers["Server"]}',
                                    'recommendation': 'Hide or modify Server header'
                                })
                                
                            break  # Use first successful connection
                    except:
                        continue
                        
        except Exception as e:
            results['details']['headers_error'] = str(e)
            
        return results
    
    async def _analyze_open_ports(self, target_ip: str) -> Dict[str, Any]:
        """Analyze open ports for vulnerabilities"""
        results = {
            'vulnerabilities': [],
            'details': {'open_ports': []}
        }
        
        try:
            # Quick port scan of common ports
            open_ports = []
            for port, service in self.common_ports.items():
                if await self._is_port_open(target_ip, port):
                    open_ports.append({'port': port, 'service': service})
                    
                    # Check for risky services
                    if port in [21, 23]:  # FTP, Telnet
                        results['vulnerabilities'].append({
                            'type': 'Insecure Service',
                            'severity': 'High',
                            'description': f'{service} on port {port} transmits data in plain text',
                            'recommendation': f'Replace {service} with secure alternative'
                        })
                    elif port == 22:  # SSH
                        # Could add SSH version/config checks here
                        pass
                        
            results['details']['open_ports'] = open_ports
            
            # Check for too many open ports
            if len(open_ports) > 5:
                results['vulnerabilities'].append({
                    'type': 'Excessive Open Ports',
                    'severity': 'Medium',
                    'description': f'{len(open_ports)} ports are open, increasing attack surface',
                    'recommendation': 'Close unnecessary ports and services'
                })
                
        except Exception as e:
            results['details']['ports_error'] = str(e)
            
        return results
    
    async def _is_port_open(self, host: str, port: int, timeout: float = 3) -> bool:
        """Check if a port is open"""
        try:
            future = asyncio.open_connection(host, port)
            reader, writer = await asyncio.wait_for(future, timeout=timeout)
            writer.close()
            await writer.wait_closed()
            return True
        except:
            return False
    
    async def _check_service_versions(self, target_ip: str) -> Dict[str, Any]:
        """Check service versions for known vulnerabilities"""
        results = {
            'vulnerabilities': [],
            'details': {'services': {}}
        }
        
        # This would typically involve service fingerprinting
        # For now, we'll do basic banner grabbing
        
        return results
    
    def _calculate_security_score(self, results: Dict[str, Any]) -> int:
        """Calculate overall security score (0-100)"""
        score = 100
        
        for vuln in results['vulnerabilities']:
            severity = vuln.get('severity', 'Low')
            if severity == 'Critical':
                score -= 25
            elif severity == 'High':
                score -= 15
            elif severity == 'Medium':
                score -= 10
            elif severity == 'Low':
                score -= 5
                
        return max(0, score)
    
    def _generate_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Generate security recommendations"""
        recommendations = []
        
        # Extract unique recommendations from vulnerabilities
        for vuln in results['vulnerabilities']:
            rec = vuln.get('recommendation', '')
            if rec and rec not in recommendations:
                recommendations.append(rec)
                
        # Add general recommendations
        if results['security_score'] < 70:
            recommendations.append('Consider hiring a security professional for comprehensive audit')
            
        return recommendations

def format_vulnerability_report(scan_result: Dict[str, Any]) -> str:
    """Format vulnerability scan results for Telegram"""
    if 'error' in scan_result:
        return f"âŒ **×©×’×™××” ×‘×¡×¨×™×§×ª ×¤×’×™×¢×•×™×•×ª**\n\n{scan_result['error']}"
    
    target = scan_result.get('target', 'Unknown')
    score = scan_result.get('security_score', 0)
    vulns = scan_result.get('vulnerabilities', [])
    
    # Determine score emoji
    if score >= 90:
        score_emoji = "ðŸŸ¢"
    elif score >= 70:
        score_emoji = "ðŸŸ¡" 
    elif score >= 50:
        score_emoji = "ðŸŸ "
    else:
        score_emoji = "ðŸ”´"
    
    report = f"ðŸ” **×“×•×— ×¡×¨×™×§×ª ×¤×’×™×¢×•×™×•×ª**\n\n"
    report += f"ðŸŽ¯ **×™×¢×“:** `{target}`\n"
    report += f"{score_emoji} **×¦×™×•×Ÿ ××‘×˜×—×”:** {score}/100\n\n"
    
    if not vulns:
        report += "âœ… **×œ× × ×ž×¦××• ×¤×’×™×¢×•×™×•×ª ×™×“×•×¢×•×ª!**\n\n"
        report += "×”×ž×¢×¨×›×ª × ×¨××™×ª ×ž××•×‘×˜×—×ª ×‘×‘×“×™×§×” ×‘×¡×™×¡×™×ª."
    else:
        # Group by severity
        critical = [v for v in vulns if v.get('severity') == 'Critical']
        high = [v for v in vulns if v.get('severity') == 'High'] 
        medium = [v for v in vulns if v.get('severity') == 'Medium']
        low = [v for v in vulns if v.get('severity') == 'Low']
        
        if critical:
            report += f"ðŸš¨ **×§×¨×™×˜×™×•×ª ({len(critical)}):**\n"
            for vuln in critical[:3]:  # Show max 3
                report += f"â€¢ {vuln['type']}: {vuln['description']}\n"
            if len(critical) > 3:
                report += f"â€¢ ×•×¢×•×“ {len(critical)-3} ×¤×’×™×¢×•×™×•×ª ×§×¨×™×˜×™×•×ª...\n"
            report += "\n"
            
        if high:
            report += f"ðŸ”´ **×’×‘×•×”×•×ª ({len(high)}):**\n"
            for vuln in high[:2]:
                report += f"â€¢ {vuln['type']}: {vuln['description']}\n"
            if len(high) > 2:
                report += f"â€¢ ×•×¢×•×“ {len(high)-2} ×¤×’×™×¢×•×™×•×ª ×’×‘×•×”×•×ª...\n"
            report += "\n"
            
        if medium:
            report += f"ðŸŸ¡ **×‘×™× ×•× ×™×•×ª ({len(medium)}):**\n"
            for vuln in medium[:2]:
                report += f"â€¢ {vuln['type']}\n"
            if len(medium) > 2:
                report += f"â€¢ ×•×¢×•×“ {len(medium)-2} ×¤×’×™×¢×•×™×•×ª ×‘×™× ×•× ×™×•×ª...\n"
            report += "\n"
            
        if low:
            report += f"ðŸ”µ **× ×ž×•×›×•×ª:** {len(low)} ×¤×’×™×¢×•×™×•×ª × ×•×¡×¤×•×ª\n\n"
    
    # Add top recommendations
    recommendations = scan_result.get('recommendations', [])
    if recommendations:
        report += "ðŸ’¡ **×”×ž×œ×¦×•×ª ×¢×™×§×¨×™×•×ª:**\n"
        for rec in recommendations[:3]:
            report += f"â€¢ {rec}\n"
        if len(recommendations) > 3:
            report += f"â€¢ ×•×¢×•×“ {len(recommendations)-3} ×”×ž×œ×¦×•×ª...\n"
    
    # Add scan info
    scan_time = scan_result.get('scan_time', 'Unknown')
    report += f"\nðŸ“… **×–×ž×Ÿ ×¡×¨×™×§×”:** {scan_time[:19].replace('T', ' ')}"
    
    return report